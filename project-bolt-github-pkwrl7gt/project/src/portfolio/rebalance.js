// src/utils/rebalance.js
// Pure functions — geen side effects.
// Output is deterministic and explainable.

export function totalPortfolioValue(holdings) {
  return holdings.reduce((s, h) => s + (Number(h.value) || 0), 0);
}

export function computeHoldingsWeights(holdings) {
  const total = totalPortfolioValue(holdings);
  return holdings.map(h => ({
    ...h,
    value: Number(h.value) || 0,
    weight: total === 0 ? 0 : (Number(h.value) / total) * 100
  }));
}

// sectorAllocation input can be generated by PortfolioContext; but we can compute fallback
export function computeSectorAllocationFromHoldings(holdings) {
  const map = {};
  holdings.forEach(h => {
    const sector = h.sector || "Overig";
    map[sector] = (map[sector] || 0) + (Number(h.value) || 0);
  });
  const total = totalPortfolioValue(holdings);
  return Object.keys(map).map(k => ({
    name: k,
    amount: map[k],
    value: total === 0 ? 0 : (map[k] / total) * 100
  })).sort((a,b) => b.value - a.value);
}

/**
 * Suggest rebalance actions based on a simple strategy.
 * strategy:
 *  - 'equal-sector' (default): aim for equal % allocation across sectors
 *  - 'proportional' : keep sector proportions but rebalance within sector to equalize holdings
 *
 * Returns:
 *  {
 *    total,
 *    holdings: [ { ...h, weight, targetValue, deltaValue, action: 'buy'|'sell'|'hold' } ],
 *    recommendations: [ { name, symbol, action, amount, pctOfPortfolio } ],
 *    targetSector: [ { name, value } ]
 *  }
 */
export function suggestRebalance(holdingsInput, opts = {}) {
  const strategy = opts.strategy || 'equal-sector';
  const holdings = computeHoldingsWeights(holdingsInput);
  const total = totalPortfolioValue(holdingsInput);

  // Build sector groups
  const sectors = {};
  holdings.forEach(h => {
    const s = h.sector || 'Overig';
    sectors[s] = sectors[s] || { name: s, holdings: [], total: 0 };
    sectors[s].holdings.push(h);
    sectors[s].total += h.value;
  });

  const sectorNames = Object.keys(sectors);
  const numSectors = sectorNames.length || 1;

  // Compute target sector allocation
  let targetSector = [];
  if (strategy === 'equal-sector') {
    const per = 100 / numSectors;
    targetSector = sectorNames.map(name => ({ name, value: per }));
  } else {
    // proportional: keep current sector%, i.e., no sector reallocation
    targetSector = sectorNames.map(name => ({
      name,
      value: (sectors[name].total / total) * 100
    }));
  }

  // For each holding, compute target value proportional inside sector
  const holdingsWithTargets = [];
  sectorNames.forEach((sname) => {
    const sec = sectors[sname];
    const secTargetPct = targetSector.find(t => t.name === sname)?.value || 0;
    const secTargetValue = (secTargetPct / 100) * total;

    // Distribute secTargetValue across holdings proportional to current holding value
    const secTotal = sec.total || 1;
    sec.holdings.forEach(h => {
      const proportionInSector = secTotal === 0 ? (1 / sec.holdings.length) : (h.value / secTotal);
      const targetValue = secTargetValue * proportionInSector;
      const deltaValue = targetValue - h.value; // positive => buy, negative => sell
      const pctOfPortfolio = total === 0 ? 0 : (deltaValue / total) * 100;
      holdingsWithTargets.push({
        ...h,
        targetValue,
        deltaValue,
        pctOfPortfolio
      });
    });
  });

  // Build user-friendly recommendations: only ones > threshold absolute (e.g., € / 1% of portfolio)
  const absThresholdPct = opts.thresholdPct || 0.5; // ignore tiny trades under 0.5% by default
  const recommendations = holdingsWithTargets
    .map(h => {
      const action = Math.abs(h.pctOfPortfolio) < absThresholdPct ? 'hold' : (h.deltaValue > 0 ? 'buy' : 'sell');
      return {
        name: h.name,
        symbol: h.symbol || null,
        action,
        amount: Math.abs(Number(h.deltaValue.toFixed(2))),
        pctOfPortfolio: (total === 0 ? 0 : Math.abs(h.pctOfPortfolio.toFixed(2))),
      };
    })
    .filter(r => r.action !== 'hold')
    .sort((a,b) => b.pctOfPortfolio - a.pctOfPortfolio);

  // Simple risk metrics
  const largestSector = Object.values(sectors).reduce((max, s) => (s.total > (max.total||0) ? s : max), {});
  const maxSectorPct = total === 0 ? 0 : ((largestSector.total || 0) / total) * 100;
  const largestHolding = holdings.reduce((max, h) => (h.value > (max.value||0) ? h : max), {});
  const largestHoldingPct = total === 0 ? 0 : ((largestHolding.value||0) / total) * 100;

  const riskSummary = {
    total,
    maxSectorPct: Number(maxSectorPct.toFixed(2)),
    largestHolding: largestHolding.name || null,
    largestHoldingPct: Number(largestHoldingPct.toFixed(2)),
    numberOfSectors: numSectors
  };

  return {
    total,
    holdings: holdingsWithTargets,
    recommendations,
    targetSector,
    riskSummary
  };
}
